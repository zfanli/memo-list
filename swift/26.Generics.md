# 26.Swift Generics

## R：小结

## 泛型

泛型代码可以根据你所定义的需求让你写出更具有灵活性的、可复用的函数和类型，这些函数和类型可以和任何类型一起工作。能使你避免重复代码，并用更清晰和抽象的方式表达意图。

泛型是 Swift 最强大的功能之一，多数 Swift 标准库就是基于泛型建立的。实际上虽然你可能没有察觉到，在这片指南中你已经在使用泛型了。比如说 Swift 的数组和字典类型就是泛型集合。你可以创建整型数组，或者字符串数组，或者其他任何类型的数组。字典类型也是相同的，你可以创建储存任何指定类型的字典类型，实际上对字典类型能储存哪些类型是没有限制的。

### 泛型解决的问题

下面是一个标注的非泛型函数，包装了两个整型参数。

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

这个函数使用 `inout` 参数。它的功能是给参数 `a` 和 `b` 的值对调。

```swift
var someInt = 3
var anotherInt = 107
swapTwoInts(&someInt, &anotherInt)
print("someInt is now \(someInt), and anotherInt is now \(anotherInt)")
// Prints "someInt is now 107, and anotherInt is now 3"
```

`swapTwoInts(_:_:)` 函数很有用，但却只能处理整型数据，如果你需要对调字符串，对调浮点数，你还得写更多的函数，比如下面的这些。

```swift
func swapTwoStrings(_ a: inout String, _ b: inout String) {
    let temporaryA = a
    a = b
    b = temporaryA
}

func swapTwoDoubles(_ a: inout Double, _ b: inout Double) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

你可能注意到了，这三个函数是完全一致的。唯一的区别在于它们能接受的参数类型。

如果能有一个函数可以对调任何类型的两个值将是非常有用的。泛型代码可以让你写出这个函数。

```swift
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
    let temporaryA = a
    a = b
    b = temporaryA
}
```

看出区别来了吗？没有？没关系我们将这个函数的第一行和上面的函数放在一起对比一下。

```swift
func swapTwoInts(_ a: inout Int, _ b: inout Int)
func swapTwoValues<T>(_ a: inout T, _ b: inout T)
```

没错，定义泛型的方法就是那个尖括号和里面的 T。T 在这里是 Types 的意思，它作为一个占位符在这里取代实际的类型名称。这个占位符不去声明类型 T 必须是什么类型，但在这里它说明了参数 `a` 和 `b` 必须是相同类型。具体 T 到底是什么类型是在每次调用这个函数时决定的。

```swift
var someInt = 3
var anotherInt = 107
swapTwoValues(&someInt, &anotherInt)
// someInt is now 107, and anotherInt is now 3

var someString = "hello"
var anotherString = "world"
swapTwoValues(&someString, &anotherString)
// someString is now "world", and anotherString is now "hello"
```

> R：文档提示，Swift 标准库中存在一个函数 `swap(_:_:)` 提供上面例子中的函数功能，如果你真的需要，不需要自己去实现一个。

### 类型参数

在上面的例子中，类型参数 T 就是一个很好的例子。类型参数指定并命名一个占位符类型，以 `<T>` 的形式写在函数名的后面。你只要指定了一个占位符类型，你就可以在参数上指定该类型，或者声明返回值类型，甚至在函数体中，你也可以用它标注类型。无论哪种场合，占位符类型 T 最终会在函数被调用时被确定。

你可以指定多个占位符类型，使用逗号隔开。

### 命名类型参数

大多数场合，泛型参数的名称是描述性的，比如在 `Dictionary<Key, Value>` 中的 `Key` 和 `Value`，以及 `Array<Element>` 中的 `Element`，这些名称可以告诉读者它与函数之间的关系。不过，当两者之前不存在有意义的关系时，通常的做法是使用 `T`、`U` 或 `V` 等字母来作为类型参数的名称。

### 泛型类型

除了泛型函数，你还可以定义泛型类型。泛型类型是指可以处理任何类型的定制化类、结构体和枚举类型，就像字典类型和数组类型一样。

这一节告诉你如何写一个叫做 `Stack` 的泛型集合类型。一个 stack 是一组有序的值（Ordered set of values），它类似于数组，但在操作集上比 Swift 的数组有更多的限制。在数组中，新的元素可以从任何位置上加入/移除，但是一个 stack 只能将新元素加在末尾，同时只允许元素从末尾移除。

> R：如果你不好理解 `Stack` 对元素添加和删除的限制用意，请尝试思考以下网页上的面包屑导航元素，新的页面导航会加在后面，而返回前一个页面实际上就是删除最后一个页面元素，类似一个递归的流程。

下面看一个图解来理解一下 `Stack` 的添加和移除行为。

```text
  ↓   ↑
  □ ■ □
■ ■ ■ ■ ■
■ ■ ■ ■ ■
■ ■ ■ ■ ■
```

1. 当前三个值；
2. 第四个值放在顶部；
3. 现在四个值，最近的值在最上面；
4. 最上面的值移除；
5. 当前又变成三个值。

下面是非泛型版本的实现。

```swift
struct IntStack {
    var items = [Int]()
    mutating func push(_ item: Int) {
        items.append(item)
    }
    mutating func pop() -> Int {
        return items.removeLast()
    }
}
```

`IntStack` 实现了对整型数据的先进先出功能。但是它只能处理整数，下面是泛型版本。

```swift
struct Stack<Element> {
    var items = [Element]()
    mutating func push(_ item: Element) {
        items.append(item)
    }
    mutating func pop() -> Element {
        return items.removeLast()
    }
}
```

它们基本都是一致是，但是一旦加上泛型之后，它的功能就被拓宽了。你现在可以创建任何类型的 `Stack` 了。

```swift
var stackOfStrings = Stack<String>()
stackOfStrings.push("uno")
stackOfStrings.push("dos")
stackOfStrings.push("tres")
stackOfStrings.push("cuatro")
// the stack now contains 4 strings
```

移除一个值。

```swift
let fromTheTop = stackOfStrings.pop()
// fromTheTop is equal to "cuatro", and the stack now contains 3 strings
```

### 扩展一个泛型类型

扩展一个泛型类型不需要像定义时那样提供类型参数列表。但是定义过的泛型类型在扩展内部是可以直接使用的。

下面的例子扩展了 `Stack` 给其添加了一个只读属性。

```swift
extension Stack {
    var topItem: Element? {
        return items.isEmpty ? nil : items[items.count - 1]
    }
}
```

看看怎么访问这个属性。

```swift
if let topItem = stackOfStrings.topItem {
    print("The top item on the stack is \(topItem).")
}
// Prints "The top item on the stack is tres."
```

### 类型限制

目前为止定义的泛型类型都是可以处理任何类型的。但是有时对泛型类型进行一定的限制是非常有用的。类型限制指定类型参数必须继承自某个类，或者实现某个特殊的协议或是协议组合。

比如 Swift 的字典类型要求 Key 的值必须是可哈希的，也就是说，它必须提供一方式让其变得唯一。字典类型要求 Key 必须是可哈希的，这样它就可以检查一个 Key 是否有对应的值了。如果没有这个限制，那字典类型插值时就不能发现一个 Key 是否已经被赋值，也不能通过一个 Key 去找指定的值了。

# 相关

> 25.[Swift Protocols](https://github.com/zfanli/notes/blob/master/swift/25.Protocols.md)
