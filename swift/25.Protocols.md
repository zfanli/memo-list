# 25.Swift Protocols

## R：小结

## 协议

协议是一个设计蓝图，定义方法、属性以及其他完成一个特殊任务的要求或部分功能。类、结构体、枚举类型都可以实现协议。任何满足一个协议要求的类型都可以称作符合该协议。

你可以扩展协议实现部分要求，或者提供符合的类型可以利用的其他额外功能。

### 协议语法

使用下面的语法定义一个协议。

```swift
protocol SomeProtocol {
    // protocol definition goes here
}
```

结构体、枚举类型、类实现协议通过列举协议在类名之后，通过冒号隔开。

```swift
struct SomeStructure: FirstProtocol, AnotherProtocol {
    // structure definition goes here
}
```

如果要继承父类，将父类名写在所有协议的前面，用逗号隔开。

```swift
class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // class definition goes here
}
```

### 属性要求

协议可以要求实现了它的类型提供指定名称和类型的实例属性或者是类型属性。但是协议不指定这个属性是不是一个计算属性，它只要求名字和类型。协议也会指定属性是可读取（gettable）或者可读写（gettable and settable）。

如果协议要求一个属性是可读写的（gettable and settable），那么一个常量属性或是一个只读的计算属性是无法满足要求的。如果协议仅要求一个属性是可读取的（gettable），那么任何类型的属性都可以满足需求，你可以根据需求绝对这个属性是否可写入（settable）。

协议中定义要求的属性必须要用 `var` 关键字。指定其是否可读写使用 `{ get set }` 的方式。例子如下。

```swift
protocol SomeProtocol {
    var mustBeSettable: Int { get set }
    var doesNotNeedToBeSettable: Int { get }
}
```

在协议中定义静态类型属性要求时必须要加上 `static` 关键字前缀。即使当一个类在实现这个协议时可能会给属性添加上 `class` 或者 `static` 关键字前缀，在协议中也要用 `static` 关键字声明。

```swift
protocol AnotherProtocol {
    static var someTypeProperty: Int { get set }
}
```

> R：实例属性和类型属性是两种作用域不同的属性。前者每个实例独立且互不影响，后者每个实例通用。类似与 Java 的类的静态属性。

下面是一个例子，展示了一个协议只要求一个实例属性。

```swift
protocol FullyNamed {
    var fullName: String { get }
}
```

一个结构体实现了这个协议。

```swift
struct Person: FullyNamed {
    var fullName: String
}
let john = Person(fullName: "John Appleseed")
// john.fullName is "John Appleseed"
```

一个类也实现了这个协议，这个实现更复杂一点。

```swift
class Starship: FullyNamed {
    var prefix: String?
    var name: String
    init(name: String, prefix: String? = nil) {
        self.name = name
        self.prefix = prefix
    }
    var fullName: String {
        return (prefix != nil ? prefix! + " " : "") + name
    }
}
var ncc1701 = Starship(name: "Enterprise", prefix: "USS")
// ncc1701.fullName is "USS Enterprise"
```

### 方法要求

协议也可以要求实现指定的实例方法或者类型方法。

```swift
protocol SomeProtocol {
    static func someTypeMethod()
}
```

下面是一个协议要求实现一个方法。

```swift
protocol RandomNumberGenerator {
    func random() -> Double
}
```

下面一个类实现了它。

```swift
class LinearCongruentialGenerator: RandomNumberGenerator {
    var lastRandom = 42.0
    let m = 139968.0
    let a = 3877.0
    let c = 29573.0
    func random() -> Double {
        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))
        return lastRandom / m
    }
}
let generator = LinearCongruentialGenerator()
print("Here's a random number: \(generator.random())")
// Prints "Here's a random number: 0.3746499199817101"
print("And another one: \(generator.random())")
// Prints "And another one: 0.729023776863283"
```

### Mutating 方法要求

在协议中声明一个方法修改实例本身的属性时需要关键字 `mutating`。结构体和枚举类型实现这个方法时也需要这个关键字，但是类的方法不需要 `mutating` 关键字。

下面定义类一个 Togglable 协议，有一个 toogle() 方法，就如其名，要求触发一个状态对转换。

```swift
protocol Togglable {
    mutating func toggle()
}
```

下面对枚举类型对其进行类实现。

```swift
enum OnOffSwitch: Togglable {
    case off, on
    mutating func toggle() {
        switch self {
        case .off:
            self = .on
        case .on:
            self = .off
        }
    }
}
var lightSwitch = OnOffSwitch.off
lightSwitch.toggle()
// lightSwitch is now equal to .on
```

### 初始化器要求

下面的例子声明要求一个初始化器。

```swift
protocol SomeProtocol {
    init(someParameter: Int)
}
```

当一个类实现这个协议时，你可以将其声明为指定初始化器或便利初始化器任意一个，不过你必须添加 `required` 修饰符。

```swift
class SomeClass: SomeProtocol {
    required init(someParameter: Int) {
        // initializer implementation goes here
    }
}
```

`required` 修饰符保证你提供一个显式的，或者继承的初始化器，使得其子类都符合这个协议。

> R；文档提示当一个类是 final 时你不需要 `required` 修饰符。因为它没有子类。

如果父类有同名的指定初始化器，并且子类要覆盖这个特殊的初始化器，则需要 `required` 和 `override` 两个关键字。

```swift
protocol SomeProtocol {
    init()
}

class SomeSuperClass {
    init() {
        // initializer implementation goes here
    }
}

class SomeSubClass: SomeSuperClass, SomeProtocol {
    // "required" from SomeProtocol conformance; "override" from SomeSuperClass
    required override init() {
        // initializer implementation goes here
    }
}
```

### 协议作为类型

协议本身不实现任何功能。但是你还是可以使用协议作为一个类型。使用协议作为类型时常被称为存在类型（existential type），含义是有一个类型 T 实现了这个协议。

你可以像使用类型一样使用协议，包括：

- 作为一个函数、方法、初始化器的参数类型或返回值类型；
- 作为常量、变量或者属性的类型；
- 作为数组、字典或者其他容器的类型。

下面是一个例子。Dice 类代表一个多面骰子，它有两个属性，一个是面数 sides，一个是随机数生成器 generator。generator 使用上文的随机数生成器的协议作为类型。

```swift
class Dice {
    let sides: Int
    let generator: RandomNumberGenerator
    init(sides: Int, generator: RandomNumberGenerator) {
        self.sides = sides
        self.generator = generator
    }
    func roll() -> Int {
        return Int(generator.random() * Double(sides)) + 1
    }
}

var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())
for _ in 1...5 {
    print("Random dice roll is \(d6.roll())")
}
// Random dice roll is 3
// Random dice roll is 5
// Random dice roll is 4
// Random dice roll is 5
// Random dice roll is 4
```

### 委派

委派是一个设计模式。委派模式允许一个类或结构体将自身部分指责委派给另一个类型的实例。要实现委派模式，先定一个协议封装需要委派出去的指责，而实现了这个协议的类型保证提供委派所需的功能性。委派可以用来相应特定的动作，或者从外部资源中恢复数据而不需要知道这个资源的基本类型。

下面的例子定义了两个协议。

```swift
protocol DiceGame {
    var dice: Dice { get }
    func play()
}
protocol DiceGameDelegate: AnyObject {
    func gameDidStart(_ game: DiceGame)
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)
    func gameDidEnd(_ game: DiceGame)
}
```

DiceGame 协议可以由任何使用骰子的游戏实现。

DiceGameDelegate 协议可以实现追踪一个 DiceGame 的进度。为了避免强引用循环，委派被声明为弱引用。DiceGameDelegate 继承 AnyObject，这一操作让其只能被类实现，这样的协议称为 Class-Only Protocols。

```swift
class SnakesAndLadders: DiceGame {
    let finalSquare = 25
    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())
    var square = 0
    var board: [Int]
    init() {
        board = Array(repeating: 0, count: finalSquare + 1)
        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02
        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08
    }
    weak var delegate: DiceGameDelegate?
    func play() {
        square = 0
        delegate?.gameDidStart(self)
        gameLoop: while square != finalSquare {
            let diceRoll = dice.roll()
            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)
            switch square + diceRoll {
            case finalSquare:
                break gameLoop
            case let newSquare where newSquare > finalSquare:
                continue gameLoop
            default:
                square += diceRoll
                square += board[square]
            }
        }
        delegate?.gameDidEnd(self)
    }
}
```

SnakesAndLadders 类初始化时创建了一个棋盘，并定义了一些数值在其中。游戏执行时，骰子生成随机数，然后 square 属性添加随机数，并加上棋盘上相应位置的数值，最终结果超过 finialSquare 则游戏结束。

下面是骰子游戏委派的实现。

```swift
class DiceGameTracker: DiceGameDelegate {
    var numberOfTurns = 0
    func gameDidStart(_ game: DiceGame) {
        numberOfTurns = 0
        if game is SnakesAndLadders {
            print("Started a new game of Snakes and Ladders")
        }
        print("The game is using a \(game.dice.sides)-sided dice")
    }
    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) {
        numberOfTurns += 1
        print("Rolled a \(diceRoll)")
    }
    func gameDidEnd(_ game: DiceGame) {
        print("The game lasted for \(numberOfTurns) turns")
    }
}
```

实际上它们是这样组合的。

```swift
let tracker = DiceGameTracker()
let game = SnakesAndLadders()
game.delegate = tracker
game.play()
// Started a new game of Snakes and Ladders
// The game is using a 6-sided dice
// Rolled a 3
// Rolled a 5
// Rolled a 4
// Rolled a 5
// The game lasted for 4 turns
```

### 用扩展添加新的协议

你可以使用扩展语法给现有的类型实现新的协议，甚至你不需要访问现有类型的源代码。关于扩展可以参考上一节。

> R：文档提示当存在现有实例时，将自动获得扩展后的内容。听上去很酷炫的热扩展。

例如下面的协议定义了一个属性用文本表述自身。

```swift
protocol TextRepresentable {
    var textualDescription: String { get }
}
```

扩展 Dice 类让其实现这个协议。

```swift
extension Dice: TextRepresentable {
    var textualDescription: String {
        return "A \(sides)-sided dice"
    }
}
```

现在 Dice 的实例都实现了 TextRepresentable 协议。

```swift
let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())
print(d12.textualDescription)
// Prints "A 12-sided dice"
```

类似的，SnakesAndLadders 类也可以实现这个协议。

```swift
extension SnakesAndLadders: TextRepresentable {
    var textualDescription: String {
        return "A game of Snakes and Ladders with \(finalSquare) squares"
    }
}
print(game.textualDescription)
// Prints "A game of Snakes and Ladders with 25 squares"
```

### 按条件实现协议

泛型类型可能仅在某些条件下满足协议的要求，例如当类型的通用参数符合协议时。你可以在扩展一个类型的时候列出制约，可以使泛型有条件地实现某个协议。通过泛型 where 小句将制约写在协议名称之后。

```swift
extension Array: TextRepresentable where Element: TextRepresentable {
    var textualDescription: String {
        let itemsAsText = self.map { $0.textualDescription }
        return "[" + itemsAsText.joined(separator: ", ") + "]"
    }
}
let myDice = [d6, d12]
print(myDice.textualDescription)
// Prints "[A 6-sided dice, A 12-sided dice]"
```

### 用扩展声明协议实现

如果一个类型已经满足了一个协议的要求，但是其没有实现这个协议，可以使用一个空的扩展来声明这个类型实现了这个协议。

```swift
struct Hamster {
    var name: String
    var textualDescription: String {
        return "A hamster named \(name)"
    }
}
extension Hamster: TextRepresentable {}


let simonTheHamster = Hamster(name: "Simon")
let somethingTextRepresentable: TextRepresentable = simonTheHamster
print(somethingTextRepresentable.textualDescription)
// Prints "A hamster named Simon"
```

### 协议类型集合

# 相关

> 24.[Swift Extensions](https://github.com/zfanli/notes/blob/master/swift/24.Extensions.md)
