# 29.Swift Memory Safety

## R：小结

## 内存安全性

默认情况下 Swift 会阻止你代码中的不安全的行为。例如 Swift 保证每个变量在被使用之前进行初始化，内存在被释放后不可访问，数组索引会检测边界。

通过要求修改内存的代码对内存进行独占访问，Swift 也可以保证对同一个内存区域进行多次访问不会冲突。因为 Swift 自动管理内存，大部分时间你根本不需要思考内存管理的问题。但是理解可能会发生的潜在冲突，可以帮助你避免编写冲突的内存访问代码。要知道，如果你的代码中存在冲突，在编译时或者运行时会报错。

### 理解内存访问的冲突

在你给变量赋值或给函数传参数时，就会发生内存访问。例如下面的代码进行了读写访问。

```swift
// A write access to the memory where one is stored.
var one = 1

// A read access from the memory where one is stored.
print("We're number \(one)!")
```

当你的代码试图多处同时对一个内存进行访问时就可能发生冲突。对同一个内存位置同时进行多次访问可能会造成不可预计的、或是矛盾的行为。在 Swift 中有很多方式跨很多行去修改一个值，这导致在它自己的修改过程中访问这个值是可能的。但是这是有问题的。

设想一个场景，你在纸上记账，可能步骤是：先写下账目；再更新合计金额。这时如果有人在你写账目的时候要求查看合计金额，那么你记账前的金额是对方想要的吗？还是你记账结束后的总额才是对方想要的？这是取决于对方的意图的。

### 内存访问的特性

内存访问存在三个特性：

- 是写入还是读取；
- 持续多久；
- 内存的位置。

如果你有两个操作满足下面的条件，那么就会发生冲突：

- 至少一个是写入操作；
- 访问相同的内存位置；
- 持续时间有交叠。

读和写的操作的区别很明显：读操作不修改内存；写操作修改内存。而内存位置指你现在访问的是什么，可以是一个变量、常量或者是属性。持续时间分为即时和长期两种。

即时访问不允许在其开始访问和结束访问一个内存位置之间让其他代码访问该内存位置。因此，两个即时访问无法同时发生在一个内存位置。例如下面的所有读写操作都是即时完成的。

```swift
func oneMore(than number: Int) -> Int {
    return number + 1
}

var myNumber = 1
myNumber = oneMore(than: myNumber)
print(myNumber)
// Prints "2"
```

而然还是有很多方式可以在其他代码执行期间对内存进行长久访问。长期访问的意思是在开始修改一个内存位置之后到修改结束这段时间内，还是允许其他代码执行的，这中间的过程就是一个交叠。一个长期访问可以和其他长期访问和即时访问进行交叠。

> R：这感觉有点像异步。

### 访问 In-Out 参数时的冲突

函数对它的 In-Out 参数有长久写入的权利。写入权限从 In-Out 参数得到赋值开始一直持续到函数调用结束。如果函数有多个 In-Out 参数，写入权限以它们出现的顺序开始。

这导致了一个结果就是你无法在函数中访问 In-Out 参数的原始变量。无论是作用域规则或者访问权限允许你这样做。所有对原始变量的访问将报错。

```swift
var stepSize = 1

func increment(_ number: inout Int) {
    number += stepSize
}

increment(&stepSize)
// Error: conflicting accesses to stepSize
```

上面的例子就是这样的。函数中使用了 stepSize 变量，那么它就不能作为 In-Out 参数传进来了，它违反了规则。因为对 stepSize 所在的内存位置同时进行了两次读写操作。一次是读取它的值，同时还要写入新的值。这两个操作交叠导致了失败。这个现象是你不能又读又改同一个内存。

解决这个问题的方法是做一个显式的拷贝。

```swift
// Make an explicit copy.
var copyOfStepSize = stepSize
increment(&copyOfStepSize)

// Update the original.
stepSize = copyOfStepSize
// stepSize is now 2
```

这样同样对 stepSize 进行了一次读和一次写的操作，但是读操作在写之前就完成了，它们没有冲突。

下面还有一个例子展示了当函数有多个 In-Out 参数时，不能传递相同的变量。

```swift
func balance(_ x: inout Int, _ y: inout Int) {
    let sum = x + y
    x = sum / 2
    y = sum - x
}
var playerOneScore = 42
var playerTwoScore = 30
balance(&playerOneScore, &playerTwoScore)  // OK
balance(&playerOneScore, &playerOneScore)
// Error: conflicting accesses to playerOneScore
```

这里对同一个变量执行两次写操作，这是不能实现的，所以会报错。

### 在方法中访问 self 导致冲突

# 相关

> 28.[Swift Automatic Reference Counting](https://github.com/zfanli/notes/blob/master/swift/28.AutomaticReferenceCounting.md)
