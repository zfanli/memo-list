# 28.Swift Automatic Reference Counting

## R：小结

## 自动引用计算

Swift 使用自动引用计算（简称 ARC）管理你的 App 的内存使用。在绝大多数情况下这意味着 Swift 的内存管理是自动的，你不需要对内存管理投入太多思考。ARC 会自动对不再使用的实例进行垃圾回收，释放内存。

然而，ARC 在一些场景下为了帮你管理内存需要你提供部分代码的更多关系信息。这篇主题描述这些场景并像你展示 ARC 如何管理你的 App 使用内存。

引用计算只针对类的示例有效。结构体和枚举类型是值类型而非引用类型，不是以引用方式储存和传递的。

### ARC 如何工作

每次当你创建一个类的实例时，ARC 都会分配一块内存用来储存和这个实例相关的信息。这个内存储存关于这个实例的所有类型信息和所有关联的属性值。

另外，当一个实例不再需要时，ARC 会释放这个实例使用的内存资源。这保证类的实例在不使用后不再占据内存。

然而如果 ARC 释放了一个仍然在使用中的实例，其后果是这个实例的属性和方法都将不能访问。实际上，这种情况下如果你尝试访问这个实例，你的应用应该会崩溃掉。

为了保证一个实例在仍然被需要的时候不会突然消失，ARC 会追踪有多少属性、常量、变量当前正在引用实例。只要还有一个引用存在，ARC 就不会对实例释放内存。

为了让这变成可能，当你赋值一个实例给属性、变量或常量时，这些属性、变量或常量会对实例进行强引用。之所以称之为“强”引用，是因为它将稳定的保持住实例，只要强引用还存在就不允许该实例被释放内存。

### ARC 实战

下面是一个例子展示了 ARC 是如何工作的。首先定义一个简单的类 `Person`，它有一个常量 `name`。

```swift
class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    deinit {
        print("\(name) is being deinitialized")
    }
}
```

> R：就不一行一行解释这个类了，相信都能看懂，文档真啰嗦。

下面定义三个 `Person?` 类型的变量，用来对之后的 `Person` 实例设置多个引用关系。它们是可选类型，所以它们会在没有赋值 `Person` 类型的值之前被初始化为 `nil`。

```swift
var reference1: Person?
var reference2: Person?
var reference3: Person?
```

先给一个变量赋值。

```swift
reference1 = Person(name: "John Appleseed")
// Prints "John Appleseed is being initialized"
```

注意初始化器中的信息被打印出来了，这确认了初始化器被执行了。

因为 `reference1` 变量被赋值了新的 `Person` 对象，这个对象有了一个强引用。而因为存在至少一个强引用存在，ARC 就会保持其存在内存之中而不去释放它。

如果你将其赋值给另外两个变量，则该对象就多了两个强引用。

```swift
reference2 = reference1
reference3 = reference1
```

现在这个实例有三个强引用。

通过给变量赋值为 `nil` 可以移除对实例的强引用。下面移除两个强引用，但是因为还存在一个强引用存在，它还不会被释放掉。

```swift
reference1 = nil
reference2 = nil
```

在第三个强引用被移除之前 ARC 都不会释放它。现在我们移除最后一个强引用，你可以看到卸载器中的消息被打印出来，表明这个实例以及被释放掉了。

```swift
reference3 = nil
// Prints "John Appleseed is being deinitialized"
```

### 类实例之间的强引用循环

#相关

> 28.[Swift Automatic Reference Counting](https://github.com/zfanli/notes/blob/master/swift/28.AutomaticReferenceCounting.md)
