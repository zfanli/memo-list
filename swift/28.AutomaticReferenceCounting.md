# 28.Swift Automatic Reference Counting

## R：小结

## 自动引用计算

Swift 使用自动引用计算（简称 ARC）管理你的 App 的内存使用。在绝大多数情况下这意味着 Swift 的内存管理是自动的，你不需要对内存管理投入太多思考。ARC 会自动对不再使用的实例进行垃圾回收，释放内存。

然而，ARC 在一些场景下为了帮你管理内存需要你提供部分代码的更多关系信息。这篇主题描述这些场景并像你展示 ARC 如何管理你的 App 使用内存。

引用计算只针对类的示例有效。结构体和枚举类型是值类型而非引用类型，不是以引用方式储存和传递的。

### ARC 如何工作

每次当你创建一个类的实例时，ARC 都会分配一块内存用来储存和这个实例相关的信息。这个内存储存关于这个实例的所有类型信息和所有关联的属性值。

另外，当一个实例不再需要时，ARC 会释放这个实例使用的内存资源。这保证类的实例在不使用后不再占据内存。

然而如果 ARC 释放了一个仍然在使用中的实例，其后果是这个实例的属性和方法都将不能访问。实际上，这种情况下如果你尝试访问这个实例，你的应用应该会崩溃掉。

为了保证一个实例在仍然被需要的时候不会突然消失，ARC 会追踪有多少属性、常量、变量当前正在引用实例。只要还有一个引用存在，ARC 就不会对实例释放内存。

为了让这变成可能，当你赋值一个实例给属性、变量或常量时，这些属性、变量或常量会对实例进行强引用。之所以称之为“强”引用，是因为它将稳定的保持住实例，只要强引用还存在就不允许该实例被释放内存。

### ARC 实战

下面是一个例子展示了 ARC 是如何工作的。首先定义一个简单的类 `Person`，它有一个常量 `name`。

```swift
class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) is being initialized")
    }
    deinit {
        print("\(name) is being deinitialized")
    }
}
```

> R：就不一行一行解释这个类了，相信都能看懂，文档真啰嗦。

下面定义三个 `Person?` 类型的变量，用来对之后的 `Person` 实例设置多个引用关系。它们是可选类型，所以它们会在没有赋值 `Person` 类型的值之前被初始化为 `nil`。

```swift
var reference1: Person?
var reference2: Person?
var reference3: Person?
```

先给一个变量赋值。

```swift
reference1 = Person(name: "John Appleseed")
// Prints "John Appleseed is being initialized"
```

注意初始化器中的信息被打印出来了，这确认了初始化器被执行了。

因为 `reference1` 变量被赋值了新的 `Person` 对象，这个对象有了一个强引用。而因为存在至少一个强引用存在，ARC 就会保持其存在内存之中而不去释放它。

如果你将其赋值给另外两个变量，则该对象就多了两个强引用。

```swift
reference2 = reference1
reference3 = reference1
```

现在这个实例有三个强引用。

通过给变量赋值为 `nil` 可以移除对实例的强引用。下面移除两个强引用，但是因为还存在一个强引用存在，它还不会被释放掉。

```swift
reference1 = nil
reference2 = nil
```

在第三个强引用被移除之前 ARC 都不会释放它。现在我们移除最后一个强引用，你可以看到卸载器中的消息被打印出来，表明这个实例以及被释放掉了。

```swift
reference3 = nil
// Prints "John Appleseed is being deinitialized"
```

### 类实例之间的强引用循环

上面的例子中，ARC 可以计算你所创建的 `Person` 实例的强引用数量，并且在不需要该实例的时候进行释放。

但是，也可能出现一个实例的强引用数量永远也不会为零的情况。这种情况一般是两个实例都保持对方的强引用，因此它们相互保持不被释放。这就是所谓的强引用循环。

要解决强引用循环，你可以将两个类的关系定义为弱引用，或者是无主引用。这个处理在后文还会解释。但是在你尝试解决这个问题之前，先了解一下造成这个问题的原因吧。

下面是一个偶尔造成强引用循环的例子。这个例子定义了 `Person` 和 `Apartment` 类，用来表示一个公寓和其住户。

```swift
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
```

每一个 `Person` 实例都有一个 name 属性和一个 apartment 属性。apartment 属性是可选的，因为可能这个人可能没有公寓。

相同的，每个 `Apartment` 实例会有一个 unit 属性和一个 tenant 属性。tenant 也是可选的，因为一个公寓可能也会没人住。

这两个类都定义了卸载器，在不需要这些实例的时候打印一些提示信息。这可以让你看看实例是否如你预期的一样被释放。

下面定义两个变量准备创建新的实例。它们的类型都是可选的，目前它们被初始化为 `nil`。

```swift
var john: Person?
var unit4A: Apartment?
```

现在我们来创建各自的实例。

```swift
john = Person(name: "John Appleseed")
unit4A = Apartment(unit: "4A")
```

现在，这两个变量拥有各自实例的强引用。

```text
john                                unit4A

↓强引用                             ↓强引用

Person 实例                         Apartment 实例
name: "John Appleseed"              unit: "4A"
apartment: nil                      tenant: nil
```

接下来将这两个实例关联起来，让 John 住进公寓，让公寓又一个住户。注意这里使用感叹号强制解包类型来赋值。

```swift
john!.apartment = unit4A
unit4A!.tenant = john
```

现在这两个实例直接相互持有对方的强引用关系。

```text
john                                        unit4A

↓强引用                                     ↓强引用

Person 实例                 ←强引用         Apartment 实例
name: "John Appleseed"      强引用→         unit: "4A"
apartment: nil                              tenant: nil
```

不幸的是，将这两个实例连接起来会造成强引用循环。两者互相持有对方的强引用，就算我们将两个变量设为 `nil`，它们的强引用计数也不会归零，ARC 无法释放它们。

```swift
john = nil
unit4A = nil
```

注意卸载器并没有执行。强引用循环阻止两个实例被 ARC 释放。这会造成你的 APP 内存泄露。

两个实例的关系如下。

```text
john                                        unit4A


Person 实例                 ←强引用         Apartment 实例
name: "John Appleseed"      强引用→         unit: "4A"
apartment: nil                              tenant: nil
```

两个实例之前的强引用仍然存在，且无法分隔。

### 解决两个类型之间的强引用循环

Swift 提供 2 种方式解决类型之间的强引用循环：弱引用和无主引用（unowned references）。

这两种方式都可以让两者相互引用但不保持对方的强引用，这样就不会进入一个强引用循环了。

在另一个实例生命周期较短时使用弱引用，因为另一个实例可能会先一步被释放掉。在上面的例子中，Apartment 的生命周期中可能有部分时间是没有住户的，所以这里住户属性可以是一个弱引用，这样就不会造成一个强引用循环了。相反，在另一个实例有类似或者更长的生命周期时使用无主引用。

### 弱引用

弱引用不保持类型的强引用关系，ARC 不会将其作为引用计数的一个，弱引用也就不会阻止 ARC 释放实例。这个行为可以阻止陷入一个强引用循环中。要使用弱引用，在属性声明前加上 `weak` 关键字。

由于不保持引用类型的强引用关系，所以有可能会出现所引用的类型已经被 ARC 释放的情况，对于这种情况，ARC 会自动将其设为 `nil`，也因此弱引用类型必须是一个可选的类型，因为在运行时它可能被设置为 `nil`。

你可以像处理可选类型那样检查弱引用的类型是否还存在。

> R：文档提示，属性监视会在弱引用类型被设置为 `nil` 时触发。

下面的示例和之前一样，不同之处在于这次 Apartment 的属性 tenant 是弱引用的。

```swift
class Person {
    let name: String
    init(name: String) { self.name = name }
    var apartment: Apartment?
    deinit { print("\(name) is being deinitialized") }
}

class Apartment {
    let unit: String
    init(unit: String) { self.unit = unit }
    weak var tenant: Person?
    deinit { print("Apartment \(unit) is being deinitialized") }
}
```

# 相关

> 28.[Swift Automatic Reference Counting](https://github.com/zfanli/notes/blob/master/swift/28.AutomaticReferenceCounting.md)
